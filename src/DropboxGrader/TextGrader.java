/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package DropboxGrader;

import static DropboxGrader.Config.configFile;
import com.dropbox.core.DbxClient;
import com.dropbox.core.DbxEntry;
import com.dropbox.core.DbxException;
import com.dropbox.core.DbxWriteMode;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Scanner;
import javax.swing.JLabel;

/**
 *
 * @author 141lyonsm
 */
public class TextGrader {
    private DbxClient client;
    private FileManager manager;
    private String filenameRemote;
    private String filenameLocal;
    private File sheet;
    private String[][] table;
    private final String delimitor="`'`"; //who would use this combination of keys in a comment
    public TextGrader(FileManager manager,DbxClient client){
        this.client=client;
        this.manager=manager;
        init();
    }
    private void init(){
        if(Config.dropboxSpreadsheetFolder==null){
            Config.reset(); //config corrupt...
        }
        filenameLocal="Grades-Period"+Config.dropboxPeriod+".txt";
        filenameRemote="/"+Config.dropboxSpreadsheetFolder+"/"+filenameLocal;
        filenameLocal=manager.getDownloadFolder()+"/"+filenameLocal;
        sheet=new File(filenameLocal);
        downloadSheet();
    }
    private void downloadSheet(){
        try{
            String code;
            DbxEntry entry=client.getMetadata(filenameRemote);
            if(entry!=null){ //file has already been created
                FileOutputStream f = new FileOutputStream(filenameLocal);
                client.getFile(filenameRemote, null, f); //download file
                f.close();
            }
            else{ //no spreadsheet file found
                createSheet();
            }
            code=DbxSession.readFromFile(sheet);
            //parse sheet into a 2d array;
            String[] lines=code.split("\n");
            int row=0;
            table=null;
            int realLines=0;
            for(String line:lines){
                if(!line.contains("/`/")&&line.contains(delimitor)){ //if its not a comment and the line contains delimitors
                    realLines++;
                }
            }
            for(int x=0;x<lines.length;x++){
                String line=lines[x];
                if(!line.contains("/`/")&&line.contains(delimitor)){ //if its not a comment and the line contains delimitors
                    String[] grades=line.split(delimitor);
                    if(table==null){
                        table=new String[realLines][grades.length];
                    }
                    for(int col=0;col<grades.length;col++){
                        table[row][col]=grades[col];
                    }
                    row++;
                }
            }
            if(table==null){ //no real data in the file
                table=new String[1][1];
                table[0][0]="";
            }
        } catch(DbxException | IOException e){
            System.err.println("An error occured while downloading the HTML spreadsheet. "+e);
        }
    }
    //make sheet, and save it to a file.
    private void createSheet(){
        try{
            File sheet=new File(filenameLocal);
            sheet.createNewFile();
            String code="/`/DO NOT EDIT THIS FILE MANUALLY. YOU WILL CORRUPT IT.\n";
            DbxSession.writeToFile(sheet, code);
            upload();
        } catch(IOException e){
            System.err.println("An error occured while creating HTML spreadsheet. "+e);
        }
    }
    private boolean uploadTable(){
        String code=convertTable();
        DbxSession.writeToFile(sheet, code);
        return upload();
    }
    private String convertTable(){
        String[] oldFileLines=DbxSession.readFromFile(sheet).split("\n");
        String code="";
        for(String line:oldFileLines){
            if(line.contains("/`/")){ //its a comment, add it to the new sheet
                code+=line+"\n";
            }
        }
        for(int x=0;x<table.length;x++){
            for(int y=0;y<table[0].length;y++){
                code+=table[x][y];
                if(y!=table[0].length-1){
                    code+=delimitor;
                }
            }
            code+="\n";
        }
        return code;
    }
    private boolean upload(){
        try{
            //upload to dropbox
            FileInputStream sheetStream = new FileInputStream(sheet);
            client.uploadFile(filenameRemote, DbxWriteMode.force(), sheet.length(), sheetStream);
            sheetStream.close();
        } catch(DbxException | IOException e){
            System.err.println("Error uploading spredsheet to dropbox. "+e);
            return false;
        }
        return true;
    }
    public static int indexOf(String substring,String str){
        boolean inSub=false;
        int subIndex=0;
        int startIndex=-1;
        for(int x=0;x<str.length();x++){
            char c=str.charAt(x);
            if(substring.charAt(subIndex)==c){
                if(!inSub){
                    startIndex=x;
                    inSub=true;
                    subIndex=0;
                }
                if(subIndex==substring.length()-1){
                    return startIndex; //will return at the first instance of substring
                }
                subIndex++;
            }
            else{
                inSub=false;
                subIndex=0;
                startIndex=-1;
            }
        }
        return -1;
    }
    public static int lastIndexOf(String substring,String str){
        Integer[] index=allIndexOf(substring,str);
        if(index.length==0){
            return -1;
        }
        return index[index.length-1];
    }
    public static Integer[] allIndexOf(String substring,String str){
        boolean inSub=false;
        ArrayList<Integer> indexes=new ArrayList();
        int subIndex=0;
        int startIndex=-1;
        for(int x=0;x<str.length();x++){
            char c=str.charAt(x);
            if(substring.length()>subIndex&&substring.charAt(subIndex)==c){
                if(!inSub){
                    startIndex=x;
                    inSub=true;
                    subIndex=0;
                }
                if(subIndex==substring.length()-1){
                    indexes.add(startIndex);
                }
                subIndex++;
            }
            else{
                inSub=false;
                subIndex=0;
                startIndex=-1;
            }
        }
        Integer[] arr=new Integer[indexes.size()];
        return indexes.toArray(arr);
    }
    private void createAssignment(int assignmentNum){
        expandTable(table.length,table[0].length+2);
        table[0][table[0].length-2]="#"+assignmentNum+" "; //should also include a description from the confirmation dialog
        table[0][table[0].length-1]="Comments";
    }
    private void createName(String name){
        expandTable(table.length+1,table[0].length);
        table[table.length-1][0]=name;
    }
    public boolean setGrade(String name,int assignmentNum,String gradeNum,String comment,JLabel statusLabel){
        downloadSheet();
        //need to check if theres already a grade written
        int nameIndex=nameIndexInTable(name);
        if(nameIndex==-1){
            createName(name);
            nameIndex=table.length-1;
        }
        else if(nameIndex==-2){
            if(statusLabel!=null){
                statusLabel.setText("Name does not follow proper capitalization. The first and last name cannot be seperated.");
            }
            return false;
        }
        int assignmentIndex=assignmentIndexInTable(assignmentNum);
        if(assignmentIndex==-1){ //need to create assignment in table
            createAssignment(assignmentNum);
            assignmentIndex=table[0].length-2;
        }
        table[nameIndex][assignmentIndex]=gradeNum;
        table[nameIndex][assignmentIndex+1]=comment;
        //convert to code, write and upload
        return uploadTable();
    }
    private String[] getGradeData(String name,int assignmentNum){
        downloadSheet();
        int nameIndex=nameIndexInTable(name);
        if(nameIndex==-1||nameIndex==-2){
            return null;
        }
        int assignmentIndex=assignmentIndexInTable(assignmentNum);
        if(assignmentIndex==-1){
            return null;
        }
        return new String[]{table[nameIndex][assignmentIndex],table[nameIndex][assignmentIndex+1]};
    }
    public String getGrade(String name,int assignmentNum){
        String[] grade=getGradeData(name,assignmentNum);
        if(grade!=null){
            if(grade[0]!=null){
                return grade[0];
            }
        }
        return null;
    }
    public String getComment(String name,int assignmentNum){
        String[] comment=getGradeData(name,assignmentNum);
        if(comment!=null){
            if(comment[1]!=null){
                return comment[1];
            }
        }
        return null;
    }
    public boolean gradeWritten(String name,int assignmentNum,JLabel statusLabel){
        return getGradeData(name,assignmentNum)!=null;
    }
    public int assignmentIndexInTable(int assignmentNumber){
        int index=-1;
        String num="#"+assignmentNumber+" ";
        for(int x=0;x<table[0].length;x++){
            if(table[0][x].contains(num)){
                return x;
            }
        }
        return index;
    }
    public int nameIndexInTable(String name){
        int index=-1;
        String[] nameParts=seperateName(name);
        if(nameParts==null){
            return -2;
        }
        for(int x=0;x<table.length;x++){
            if(table[x][0].contains(nameParts[0])&&table[x][0].contains(nameParts[1])){
                return x;
            }
        }
        return index;
    }
    private String[] seperateName(String name){
        String firstName,lastName;
        int upercaseIndex=-1;
        char c;
        for(int x=0;x<name.length();x++){
            c=name.charAt(x);
            if(Character.isUpperCase(c)){
                if(x!=0){
                    upercaseIndex=x;
                    break;
                }
            }
        }
        if(upercaseIndex==-1){
            return null;
        }
        firstName=name.substring(0, upercaseIndex);
        lastName=name.substring(upercaseIndex, name.length());
        
        return new String[]{firstName,lastName};
    }
    public void reset(){
        init();
    }

    private int selectiveCountRepeats(String startString, String endString,String counted,String str) {
        int startIndex=indexOf(startString,str)+startString.length();
        str=str.substring(startIndex); //cut off the front part
        int endIndex=indexOf(endString,str);
        str=str.substring(0,endIndex); //cut off the end part
        
        Integer[] occurances=allIndexOf(counted,str);
        return occurances.length;
    }
    private void expandTable(int rows,int cols){
        if(table==null||(rows<table.length&&cols<table[0].length)){
            System.err.println("Tried to shrink the table instead of expanding it.");
            return;
        }
        if(rows==table.length&&cols==table[0].length){
            return; //doesn't need to be expanded
        }
        String[][] newTable=new String[rows][cols];
        for(int x=0;x<table.length;x++){
            for(int y=0;y<table[0].length;y++){
                newTable[x][y]=table[x][y];
            }
        }
        table=newTable;
    }
}
